<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äºŒäººéº»å°‡ v0.2 - å®Œæ•´ä¿®å¾©ç‰ˆ</title>
    <style>
        :root {
            --bg-color: #2e7d32;
            --tile-w: 42px;
            --tile-h: 58px;
            --tile-font: 36px;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1b5e20;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }
        #game-area {
            width: 950px;
            height: 720px;
            background-color: var(--bg-color);
            border: 8px solid #5d4037;
            border-radius: 10px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        /* å€åŸŸä½ˆå±€ */
        .player-zone { padding: 5px 15px; min-height: 140px; position: relative; display: flex; flex-direction: column; align-items: center; }
        .ai-zone {
            border-bottom: 2px solid rgba(255,255,255,0.2);
            justify-content: flex-start; padding-top: 15px;
        }
        .user-zone {
            border-top: 2px solid rgba(255,255,255,0.2);
            justify-content: flex-end; padding-bottom: 10px;
        }
        .center-zone {
            flex-grow: 1; display: flex; justify-content: center; align-items: center;
            flex-direction: column; position: relative;
        }

        /* æ‰‹ç‰Œå®¹å™¨ */
        .hand-container { display: flex; align-items: flex-end; gap: 20px; height: 70px; margin-bottom: 5px; }
        .hand-tiles { display: flex; align-items: flex-end; }
        .meld-tiles { display: flex; gap: 10px; opacity: 0.9; }
        .meld-group { display: flex; margin-left: 5px; border-bottom: 3px solid rgba(0,0,0,0.3); }

        /* ç‰Œæ¨£å¼ */
        .tile {
            width: var(--tile-w); height: var(--tile-h);
            background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
            color: #000; border-radius: 4px;
            display: inline-flex; justify-content: center; align-items: center;
            font-size: var(--tile-font); margin: 2px;
            cursor: pointer;
            box-shadow: 1px 1px 1px rgba(0,0,0,0.2), 2px 2px 5px rgba(0,0,0,0.3);
            position: relative; transition: transform 0.1s; line-height: 1;
        }
        .tile:hover { transform: translateY(-4px); }
        .tile.selected { border: 3px solid #d32f2f; transform: translateY(-8px); }
        .tile.hidden { background: #d88e6c; color: transparent; border: 1px solid #a16a4f; } 
        
        /* å¯¶ç‰Œé«˜å…‰ */
        .tile.dora-tile { 
            box-shadow: 0 0 8px 3px #ffd700, inset 0 0 10px rgba(255, 215, 0, 0.3); 
            border: 1px solid #b7950b; z-index: 10;
        }
        
        .meld-group .tile { transform: scale(0.9); margin: 0; cursor: default; }
        .meld-group .tile:hover { transform: scale(0.9); }

        /* ç‰Œæ²³ */
        .river {
            display: flex; flex-wrap: wrap; width: 360px; height: 90px;
            background: rgba(0,0,0,0.15); border-radius: 6px; padding: 5px;
            justify-content: flex-start; align-content: flex-start; margin: 5px;
        }
        .river .tile { width: 28px; height: 38px; font-size: 24px; margin: 1px; cursor: default; box-shadow: none; }
        .river .tile:hover { transform: none; }
        .river .tile.dora-tile { box-shadow: 0 0 4px 1px #ffd700; }

        /* å¯¶ç‰Œå€ */
        #dora-area {
            display: flex; gap: 10px; margin-bottom: 5px;
            background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 8px;
        }
        .dora-label { color: #ffd700; font-weight: bold; font-size: 12px; text-align: center; }

        /* [ä¿®æ­£ 2] æŒ‰éˆ•é®æ“‹ä¿®å¾© */
        #naki-buttons {
            position: absolute; bottom: 160px; display: flex; gap: 10px; z-index: 150; display: none;
            pointer-events: none; /* è®“æ»‘é¼ ç©¿é€å®¹å™¨ */
        }
        .btn-naki {
            background: rgba(255, 255, 255, 0.9); color: #d32f2f;
            border: 2px solid #d32f2f; font-size: 20px; font-weight: bold;
            padding: 5px 15px; border-radius: 50px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); transition: transform 0.1s;
            pointer-events: auto; /* æŒ‰éˆ•æœ¬èº«æ¢å¾©å¯é»æ“Š */
        }
        .btn-naki:hover { transform: scale(1.1); background: #fff; }
        
        #next-round-btn {
            display: none; padding: 15px 40px; font-size: 24px;
            background: linear-gradient(to bottom, #4caf50, #2e7d32); color: white;
            border: 2px solid #fff; border-radius: 50px; box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: pointer; z-index: 100; animation: pulse 1.5s infinite; margin-top: 15px;
        }
        #next-round-btn:hover { filter: brightness(1.2); }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* UI åˆ†æ•¸ */
        .score-badge {
            position: absolute; background: rgba(0,0,0,0.6); padding: 5px 12px;
            border-radius: 8px; font-family: 'Consolas', monospace; color: #ffd700; 
            border: 1px solid rgba(255,255,255,0.3); z-index: 50;
        }
        #ai-score-container { top: 10px; left: 10px; }
        #user-score-container { bottom: 10px; left: 10px; border-color: #ffd700; }
        
        #phase-indicator {
            position: absolute; top: 10px; right: 10px;
            font-weight: bold; background: rgba(0,0,0,0.4); padding: 5px 15px;
            border-radius: 20px; border: 1px solid rgba(255,255,255,0.2);
        }

        #info-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95); padding: 30px; border-radius: 12px;
            text-align: center; z-index: 200; display: none; min-width: 300px;
            border: 2px solid #ffd700;
        }
        
        .controls { margin-top: 5px; display: flex; gap: 10px; position: relative; z-index: 100; }
        button {
            background: #ffb300; border: none; padding: 8px 16px;
            font-weight: bold; cursor: pointer; border-radius: 6px; font-size: 16px;
        }
        button:disabled { background: #757575; color: #aaa; cursor: not-allowed; }

        /* Modal Styles */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center;
            z-index: 300; backdrop-filter: blur(5px);
            transition: background 0.3s;
        }
        .modal-content {
            background: #fff; color: #333; padding: 25px; border-radius: 12px; 
            max-width: 700px; width: 95%; text-align: center;
            transition: all 0.3s;
        }
        
        /* Glass Mode */
        .modal-overlay.glass-mode {
            background: rgba(0, 0, 0, 0.2); 
            backdrop-filter: none; 
            align-items: flex-end; 
            padding-bottom: 50px;
        }
        .modal-content.glass-mode {
            background: rgba(20, 40, 20, 0.9); 
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: #fff;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        .modal-content.glass-mode #picked-display {
            color: #ffeb3b !important; 
            text-shadow: 1px 1px 2px black;
        }
        .modal-content.glass-mode .tile-picker-group {
            background: rgba(255, 255, 255, 0.15); 
        }
        
        .tile-picker-group {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 4px; 
            margin: 5px 0; padding: 5px; background: #f5f5f5; border-radius: 8px;
        }
    </style>
</head>
<body>

<div id="game-area">
    <div id="ai-score-container" class="score-badge">AI: <span id="score-ai">30000</span></div>
    <div id="phase-indicator">Phase: A</div>

    <div class="player-zone ai-zone">
        <div class="hand-container">
            <div id="ai-hand" class="hand-tiles"></div>
            <div id="ai-melds" class="meld-tiles"></div>
        </div>
        <div class="river" id="ai-river"></div>
    </div>

    <div class="center-zone">
        <div id="dora-area">
            <div><div class="dora-label">DORA</div><div class="tile" id="dora-indicator"></div></div>
            <div id="ura-dora-container" style="display:none; opacity: 0.5;">
                <div class="dora-label">URA</div><div class="tile hidden" id="ura-dora-indicator"></div>
            </div>
        </div>

        <div id="status-msg" style="font-size: 24px; text-shadow: 1px 1px 4px black; font-weight: bold;">ç­‰å¾…é–‹å§‹...</div>
        <div id="deck-info" style="margin-top:5px; font-size:14px; opacity: 0.8;">å‰©é¤˜ç‰Œå±±: <span id="wall-count">0</span></div>

        <button id="next-round-btn" onclick="startNewRound()">é–‹å§‹ä¸‹ä¸€å±€</button>

        <div id="naki-buttons">
            <button class="btn-naki" id="btn-chi" onclick="doCall('CHI')">åƒ</button>
            <button class="btn-naki" id="btn-pon" onclick="doCall('PON')">ç¢°</button>
            <button class="btn-naki" id="btn-kan" onclick="doCall('KAN')">æ§“</button>
            <button class="btn-naki btn-skip" style="border-color:#666; color:#666;" onclick="skipCall()">è·³é</button>
        </div>
    </div>

    <div class="player-zone user-zone">
        <div class="river" id="user-river"></div>
        <div class="hand-container">
            <div id="user-melds" class="meld-tiles"></div>
            <div id="user-hand" class="hand-tiles"></div>
        </div>
        <div class="controls">
            <button id="btn-tenpai" onclick="openDeclareModal()" disabled>å®£å‘Šè½ç‰Œ</button>
            <button id="btn-restart" onclick="resetFullGame()" style="background:#e53935; color:white;">å…¨éƒ¨é‡ç½®</button>
        </div>
    </div>

    <div id="user-score-container" class="score-badge">YOU: <span id="score-user">30000</span></div>
</div>

<div id="info-panel">
    <h2 id="info-title" style="color:#ffb300;">Title</h2>
    <p id="info-text" style="color:white; margin: 20px 0;">Message</p>
    <button onclick="closeInfo()">ç¢ºå®š</button>
</div>

<div class="modal-overlay" id="picker-modal">
    <div class="modal-content">
        <h2 id="picker-title">è«‹é¸æ“‡</h2>
        <p id="picker-desc">èªªæ˜</p>
        <div style="margin: 10px; font-size: 24px; color: #d32f2f;" id="picked-display"></div>
        <div id="tile-picker-area"></div>
        <br>
        <button onclick="submitPicker()" style="background:#4caf50; color:white; padding: 10px 30px;">ç¢ºèª</button>
        <button onclick="closePicker()" style="background:#9e9e9e; color:white;">å–æ¶ˆ</button>
    </div>
</div>

<script>
    const TILES = [
        "ğŸ€‡","ğŸ€ˆ","ğŸ€‰","ğŸ€Š","ğŸ€‹","ğŸ€Œ","ğŸ€","ğŸ€","ğŸ€", 
        "ğŸ€™","ğŸ€š","ğŸ€›","ğŸ€œ","ğŸ€","ğŸ€","ğŸ€Ÿ","ğŸ€ ","ğŸ€¡", 
        "ğŸ€","ğŸ€‘","ğŸ€’","ğŸ€“","ğŸ€”","ğŸ€•","ğŸ€–","ğŸ€—","ğŸ€˜", 
        "ğŸ€€","ğŸ€","ğŸ€‚","ğŸ€ƒ","ğŸ€†","ğŸ€…","ğŸ€„"          
    ];

    let deck = [], deadWall = [];
    let doraIndicator, uraDoraIndicator;
    let uraRevealed = false;

    // [æ–°å¢] å®£å‘Šç‹€æ…‹æ——æ¨™
    let isDeclaring = false;

    let players = {
        user: { hand: [], melds: [], river: [], score: 30000, isTenpai: false, waits: [] },
        ai: { hand: [], melds: [], river: [], score: 30000, isTenpai: false, waits: [] }
    };
    let turn = 'user', phase = 'A';
    let attacker = null, defender = null;
    let drawCount = 0, maxDraws = 5;
    let pickerMode = '', selectedTiles = [];
    let pendingDiscard = null, pendingDiscarder = null;

    function resetFullGame() { players.user.score = 30000; players.ai.score = 30000; startNewRound(); }

    function startNewRound() {
        let allTiles = [];
        for(let i=0; i<34; i++) for(let j=0; j<4; j++) allTiles.push({id: i, char: TILES[i], uid: i*4+j});
        deck = shuffle(allTiles);
        deadWall = deck.splice(0, 14);
        doraIndicator = deadWall[4]; uraDoraIndicator = deadWall[5];
        
        uraRevealed = false;
        isDeclaring = false; // é‡ç½®

        players.user.hand = []; players.user.melds = []; players.user.river = []; 
        players.user.isTenpai = false; players.user.waits = [];
        players.ai.hand = []; players.ai.melds = []; players.ai.river = []; 
        players.ai.isTenpai = false; players.ai.waits = [];

        turn = 'user'; phase = 'A';
        attacker = null; defender = null;

        for(let i=0; i<13; i++) { drawTile('user'); drawTile('ai'); }
        sortHand('user'); sortHand('ai');
        drawTile('user'); 

        document.getElementById('next-round-btn').style.display = 'none';
        resetDoraUI(); 
        updateUI();
        showStatus("Phase A: ä½ çš„å›åˆ");
        document.getElementById('btn-tenpai').disabled = false;
        closePicker(); hideNakiButtons();
    }

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function onRoundEnd() {
        revealAIHand();
        document.getElementById('next-round-btn').style.display = 'block';
        showStatus("æœ¬å±€çµæŸã€‚è«‹æª¢è¨ç‰Œå±€ï¼Œæº–å‚™å¥½å¾Œé»æ“ŠæŒ‰éˆ•ã€‚");
        document.getElementById('btn-tenpai').disabled = true;
        hideNakiButtons();
    }

    function getNextDora(id) {
        if(id <= 8) return (id === 8) ? 0 : id + 1;
        if(id <= 17) return (id === 17) ? 9 : id + 1;
        if(id <= 26) return (id === 26) ? 18 : id + 1;
        if(id <= 30) return (id === 30) ? 27 : id + 1;
        return (id === 33) ? 31 : id + 1;
    }
    function isDora(tileId) {
        if(tileId === getNextDora(doraIndicator.id)) return true;
        if(uraRevealed && tileId === getNextDora(uraDoraIndicator.id)) return true;
        return false;
    }
    function resetDoraUI() {
        const d = document.getElementById('dora-indicator'); d.innerText = doraIndicator.char; d.classList.remove('hidden');
        document.getElementById('ura-dora-container').style.display = 'none';
    }
    function showUraDora() {
        uraRevealed = true;
        const u = document.getElementById('ura-dora-indicator'); u.innerText = uraDoraIndicator.char; u.classList.remove('hidden');
        document.getElementById('ura-dora-container').style.display = 'block'; 
        document.getElementById('ura-dora-container').style.opacity = '1';
        updateUI();
    }

    function drawTile(who) {
        if(deck.length === 0) return null;
        const tile = deck.pop(); players[who].hand.push(tile); return tile;
    }
    function drawRinshan(who) {
        if(deadWall.length === 0) return null;
        const tile = deadWall.pop(); players[who].hand.push(tile); return tile;
    }
    function sortHand(who) { players[who].hand.sort((a,b) => a.id - b.id); }

    function revealAIHand() {
        const aiDiv = document.getElementById('ai-hand'); aiDiv.innerHTML = '';
        players.ai.hand.sort((a,b) => a.id - b.id);
        players.ai.hand.forEach(tile => {
            let d = document.createElement('div'); d.className = 'tile'; 
            if(isDora(tile.id)) d.classList.add('dora-tile');
            d.innerText = tile.char; d.style.boxShadow = "0 0 5px yellow";
            aiDiv.appendChild(d);
        });
    }

    function handleTileClick(index) {
        if(phase !== 'A' || turn !== 'user') return;
        
        // --- [ä¿®æ­£ 1] å®£å‘Šè½ç‰Œå¾Œçš„å‡ºç‰Œé‚è¼¯ ---
        if(isDeclaring) {
            // è¦å‰‡ï¼šå¿…é ˆæ‰“å‡ºæœ€å³é‚Šå‰›æ‘¸çš„é‚£å¼µ
            if(index !== players.user.hand.length - 1) {
                alert("å®£å‘Šè½ç‰Œæ™‚ï¼Œè«‹æ¨¡åˆ‡ï¼ˆæ‰“å‡ºæœ€å³é‚Šå‰›æ‘¸åˆ°çš„ç‰Œï¼‰ï¼");
                return;
            }
            // æ‰“ç‰Œ
            const discarded = players.user.hand.splice(index, 1)[0];
            players.user.river.push(discarded);
            
            sortHand('user');
            updateUI();
            
            // è§£é™¤å®£å‘Šç‹€æ…‹ï¼Œæ­£å¼é€²å…¥ Phase B
            isDeclaring = false;
            players.user.isTenpai = true;
            attacker = 'user'; defender = 'ai'; 
            startPhaseB();
            return;
        }
        // --------------------------------

        const discarded = players.user.hand.splice(index, 1)[0];
        players.user.river.push(discarded);
        sortHand('user'); updateUI(); 
        
        pendingDiscard = discarded; pendingDiscarder = 'user';
        if(checkDraw()) return;

        if(aiCheckCall(discarded)) {
            showStatus("AI é³´ç‰Œ!");
            setTimeout(() => {
                aiExecuteCall(discarded);
                turn = 'ai'; setTimeout(aiDiscardPhase, 1000);
            }, 800);
        } else {
            turn = 'ai'; showStatus("AI æ€è€ƒä¸­..."); setTimeout(aiTurn, 800);
        }
    }

    function aiTurn() {
        if(phase !== 'A') return;
        drawTile('ai');
        if(!players.ai.isTenpai && players.ai.melds.length === 0 && Math.random() < 0.08 && deck.length > 10) {
            aiDeclareTenpai(); return;
        } else if (!players.ai.isTenpai && players.ai.melds.length > 0 && Math.random() < 0.1) {
             aiDeclareTenpai(); return;
        }
        aiDiscardPhase();
    }
    
    function aiDiscardPhase() {
        const discardIdx = Math.floor(Math.random() * players.ai.hand.length);
        const discarded = players.ai.hand.splice(discardIdx, 1)[0];
        players.ai.river.push(discarded);
        updateUI();
        
        if(checkDraw()) return;

        pendingDiscard = discarded; pendingDiscarder = 'ai';
        const canChi = checkChi(players.user.hand, discarded);
        const canPon = checkPon(players.user.hand, discarded);
        const canKan = checkKan(players.user.hand, discarded);
        
        if(canChi || canPon || canKan) {
            showNakiButtons(canChi, canPon, canKan); showStatus("æ˜¯å¦è¦é³´ç‰Œ?");
        } else {
            proceedToUserTurn();
        }
    }

    // --- [ä¿®æ­£] ç¬¬å››é»ï¼šè‡ªæ‘¸ç‰Œç¨ç«‹é¡¯ç¤ºé‚è¼¯ ---
    function proceedToUserTurn() {
        turn = 'user';
        sortHand('user'); // å…ˆæ•´ç†èˆŠç‰Œ
        drawTile('user'); // å†æ‘¸æ–°ç‰Œ (æ”¾æœ€å¾Œ)
        updateUI(); 
        showStatus("Phase A: ä½ çš„å›åˆ");
    }

    function checkPon(hand, tile) { return hand.filter(t => t.id === tile.id).length >= 2; }
    function checkKan(hand, tile) { return hand.filter(t => t.id === tile.id).length === 3; }
    function checkChi(hand, tile) {
        if(tile.id >= 27) return false;
        let min, max;
        if(tile.id <= 8) { min=0; max=8; } else if(tile.id <= 17) { min=9; max=17; } else { min=18; max=26; }
        const ids = hand.map(t => t.id); const t = tile.id;
        const hasM2 = (t-2 >= min) && ids.includes(t-2);
        const hasM1 = (t-1 >= min) && ids.includes(t-1);
        const hasP1 = (t+1 <= max) && ids.includes(t+1);
        const hasP2 = (t+2 <= max) && ids.includes(t+2);
        return (hasM2 && hasM1) || (hasM1 && hasP1) || (hasP1 && hasP2);
    }
    function showNakiButtons(c, p, k) {
        const div = document.getElementById('naki-buttons');
        document.getElementById('btn-chi').style.display = c ? 'block' : 'none';
        document.getElementById('btn-pon').style.display = p ? 'block' : 'none';
        document.getElementById('btn-kan').style.display = k ? 'block' : 'none';
        div.style.display = 'flex';
    }
    function hideNakiButtons() { document.getElementById('naki-buttons').style.display = 'none'; }
    function skipCall() { hideNakiButtons(); proceedToUserTurn(); }
    
    function doCall(type) {
        hideNakiButtons(); players[pendingDiscarder].river.pop(); 
        if(type === 'PON') performPon('user', pendingDiscard);
        else if (type === 'KAN') performKan('user', pendingDiscard);
        else if (type === 'CHI') performChi('user', pendingDiscard); 
        
        // é³´ç‰Œå¾Œä¹Ÿéœ€è¦æ‰“ç‰Œï¼Œé€™è£¡ä¹Ÿå¥—ç”¨ gap é‚è¼¯ (å› ç‚ºæ‰‹ç‰Œæ•¸æœƒè®Š)
        // ç°¡å–®èµ·è¦‹ï¼Œé³´ç‰Œå¾Œå…ˆä¸ gapï¼Œæ‰“ç‰Œå¾Œè‡ªç„¶æœƒæ•´ç†
        sortHand('user');
        turn = 'user'; updateUI(); showStatus("é³´ç‰ŒæˆåŠŸï¼Œè«‹æ‰“å‡ºä¸€å¼µç‰Œ");
    }

    function performPon(who, tile) {
        const hand = players[who].hand; let removed = 0, newHand = [], meldTiles = [tile];
        for(let t of hand) { if(t.id === tile.id && removed < 2) { meldTiles.push(t); removed++; } else newHand.push(t); }
        players[who].hand = newHand; players[who].melds.push(meldTiles);
    }
    function performKan(who, tile) {
        const hand = players[who].hand; let removed = 0, newHand = [], meldTiles = [tile];
        for(let t of hand) { if(t.id === tile.id && removed < 3) { meldTiles.push(t); removed++; } else newHand.push(t); }
        players[who].hand = newHand; players[who].melds.push(meldTiles); 
        drawRinshan(who); 
    }
    function performChi(who, tile) {
        const hand = players[who].hand; let ids = hand.map(t => t.id); let t = tile.id;
        let min, max; if(t<=8){min=0;max=8;} else if(t<=17){min=9;max=17;} else {min=18;max=26;}
        let pairToEat = [];
        if(t-1>=min && t+1<=max && ids.includes(t-1) && ids.includes(t+1)) pairToEat = [t-1, t+1];
        else if (t-2>=min && t-1>=min && ids.includes(t-2) && ids.includes(t-1)) pairToEat = [t-2, t-1];
        else if (t+1<=max && t+2<=max && ids.includes(t+1) && ids.includes(t+2)) pairToEat = [t+1, t+2];
        let newHand = [], meldTiles = [tile], p1=false, p2=false;
        for(let tileObj of hand) {
            if(!p1 && tileObj.id === pairToEat[0]) { meldTiles.push(tileObj); p1 = true; }
            else if(!p2 && tileObj.id === pairToEat[1]) { meldTiles.push(tileObj); p2 = true; }
            else newHand.push(tileObj);
        }
        meldTiles.sort((a,b) => a.id - b.id);
        players[who].hand = newHand; players[who].melds.push(meldTiles);
    }
    function aiCheckCall(tile) { return checkPon(players.ai.hand, tile); }
    function aiExecuteCall(tile) { players.user.river.pop(); performPon('ai', tile); updateUI(); }
    function checkDraw() {
        if(deck.length === 0) { showInfo("æµå±€", "ç‰Œå±±å·²ç©ºã€‚", onRoundEnd); return true; }
        return false;
    }

    // --- Phase B ---
    function openDeclareModal() {
        // [ä¿®æ­£ 3] åªæœ‰åœ¨ç©å®¶å›åˆä¸”æ‰‹ç‰Œæ»¿æ™‚(æ‘¸äº†ç‰Œ)æ‰èƒ½æŒ‰ï¼Œ
        // ä½†ç‚ºäº†ä¿éšªï¼Œé€™è£¡åªæª¢æŸ¥åŸºæœ¬ç‹€æ…‹
        if(phase !== 'A' || turn !== 'user') return;
        pickerMode = 'DECLARE'; openPicker("å®£å‘Šè½ç‰Œ", "é¸æ“‡æ‚¨è½çš„ç‰Œ");
    }
    function aiDeclareTenpai() {
        players.ai.isTenpai = true;
        let count = Math.floor(Math.random() * 2) + 1; 
        players.ai.waits = []; for(let i=0;i<count;i++) players.ai.waits.push(Math.floor(Math.random()*34));
        
        // [ä¿®æ­£ 1] AI å®£å‘Šæ™‚ï¼Œå¿…é ˆæ‰“å‡ºå‰›æ‘¸çš„ç‰Œ
        const discarded = players.ai.hand.pop(); 
        players.ai.river.push(discarded);
        updateUI();

        showInfo("AI å®£å‘Š", "AI å®£å‘Šè½ç‰Œï¼(å·²æ¨¡åˆ‡)", () => { attacker = 'ai'; defender = 'user'; startPhaseB(); });
    }
    function startPhaseB() {
        phase = 'B_GUESS'; drawCount = 0; document.getElementById('btn-tenpai').disabled = true;
        hideNakiButtons(); updateUI();
        if(defender === 'user') { pickerMode = 'GUESS'; setTimeout(() => { openPicker("Phase B", "æŒ‡å‡ºAIè½çš„ç‰Œ"); }, 500); }
        else { showStatus("Phase B: AI çŒœæ¸¬ä¸­..."); setTimeout(aiGuess, 2000); }
    }
    function aiGuess() {
        const g1 = Math.floor(Math.random()*34); let g2 = Math.floor(Math.random()*34); while(g2===g1) g2=Math.floor(Math.random()*34);
        const hit = players.user.waits.some(w => [g1,g2].includes(w));
        let msg = `AI æŒ‡å‡º: ${TILES[g1]} ${TILES[g2]}`;
        if(hit) showInfo("Phase B", `${msg}ã€‚AI çŒœä¸­äº†ï¼(é˜²å®ˆæˆåŠŸ)`, onRoundEnd);
        else showInfo("Phase B", `${msg}ã€‚æ²’çŒœä¸­ï¼ä½ ç²å¾—è‡ªæ‘¸æ©Ÿæœƒã€‚`, startDrawPhase);
    }
    function checkGuess(ids) {
        const hit = players.ai.waits.some(w => ids.includes(w));
        if(hit) { revealAIHand(); showInfo("Phase B", "ä½ çŒœä¸­äº†ï¼(AIæ‰‹ç‰Œå…¬é–‹)", onRoundEnd); }
        else showInfo("Phase B", "æ²’çŒœä¸­... AI è‡ªæ‘¸ã€‚", startDrawPhase);
    }
    function startDrawPhase() { phase = 'B_DRAW'; drawCount = 0; executeDrawLoop(); }
    function executeDrawLoop() {
        if(deck.length === 0) { showInfo("æµå±€", "ç‰Œå±±ç©ºäº†ã€‚", onRoundEnd); return; }
        if(drawCount >= maxDraws) { showInfo("è‡ªæ‘¸å¤±æ•—", "æ©Ÿæœƒç”¨ç›¡ï¼Œæ”»å®ˆäº¤æ›", () => startPhaseB()); return; }
        drawCount++;
        const tile = deck.pop(); updateUI();
        let msg = `${attacker==='user'?'ä½ ':'AI'} ç¬¬${drawCount}æ¬¡è‡ªæ‘¸: ${tile.char}`;
        const isWin = players[attacker].waits.includes(tile.id);
        if(attacker === 'user') {
            if(isWin) {
                setTimeout(() => {
                    if(confirm(`æ‘¸åˆ° ${tile.char}ï¼\nå®£å‘Šè‡ªæ‘¸å—ï¼Ÿ`)) { showUraDora(); showInfo("èƒ¡ç‰Œï¼", "è‡ªæ‘¸ç²å‹ï¼", onRoundEnd); }
                    else { players.user.river.push(tile); updateUI(); setTimeout(executeDrawLoop, 500); }
                }, 100);
            } else { showStatus(msg + " ...æœªä¸­"); players.user.river.push(tile); setTimeout(executeDrawLoop, 1000); }
        } else {
            showStatus(msg);
            if(isWin) { players.ai.hand.push(tile); showUraDora(); revealAIHand(); setTimeout(() => showInfo("æ•—åŒ—", `AI è‡ªæ‘¸ ${tile.char}ï¼`, onRoundEnd), 500); }
            else { players.ai.river.push(tile); setTimeout(executeDrawLoop, 800); }
        }
    }

    // --- UI Update ---
    function updateUI() {
        const userDiv = document.getElementById('user-hand'); userDiv.innerHTML = '';
        
        // [ä¿®æ­£ 4] è‡ªæ‘¸ç‰Œ GAP åˆ¤å®š
        const needGap = (players.user.hand.length % 3 === 2) && (turn === 'user') && (phase === 'A');

        players.user.hand.forEach((tile, idx) => {
            let d = document.createElement('div'); d.className = 'tile';
            if(isDora(tile.id)) d.classList.add('dora-tile');
            d.innerText = tile.char; d.onclick = () => handleTileClick(idx);
            
            if(needGap && idx === players.user.hand.length - 1) d.style.marginLeft = "20px";
            
            userDiv.appendChild(d);
        });
        renderMelds('user', 'user-melds');

        const aiDiv = document.getElementById('ai-hand'); 
        if(document.getElementById('next-round-btn').style.display === 'none') {
            aiDiv.innerHTML = '';
            players.ai.hand.forEach(t => { let d = document.createElement('div'); d.className = 'tile hidden'; aiDiv.appendChild(d); });
        }
        renderMelds('ai', 'ai-melds');
        renderRiver('user', 'user-river'); renderRiver('ai', 'ai-river');
        document.getElementById('wall-count').innerText = deck.length;
        
        let pText = "A (æº–å‚™)";
        if(phase === 'B_GUESS') pText = "B (è­˜ç ´ä¸­)";
        if(phase === 'B_DRAW') pText = `B (è‡ªæ‘¸ ${drawCount}/5)`;
        document.getElementById('phase-indicator').innerText = pText;

        document.getElementById('score-ai').innerText = players.ai.score;
        document.getElementById('score-user').innerText = players.user.score;

        // [ä¿®æ­£ 3] å¼·åˆ¶åˆ·æ–°æŒ‰éˆ•ç‹€æ…‹
        const btn = document.getElementById('btn-tenpai');
        // åªæœ‰åœ¨ (Phase A) AND (è¼ªåˆ°ç©å®¶) AND (éå®£å‘Šé€²è¡Œä¸­) æ™‚æ‰å•Ÿç”¨
        if(phase === 'A' && turn === 'user' && !isDeclaring) {
            btn.disabled = false;
        } else {
            btn.disabled = true;
        }
    }

    function renderMelds(who, elId) {
        const div = document.getElementById(elId); div.innerHTML = '';
        players[who].melds.forEach(group => {
            let gDiv = document.createElement('div'); gDiv.className = 'meld-group';
            group.forEach(tile => {
                let d = document.createElement('div'); d.className = 'tile';
                if(isDora(tile.id)) d.classList.add('dora-tile');
                d.innerText = tile.char; gDiv.appendChild(d);
            });
            div.appendChild(gDiv);
        });
    }

    function renderRiver(who, elId) {
        const div = document.getElementById(elId); div.innerHTML = '';
        players[who].river.forEach(tile => {
            let d = document.createElement('div'); d.className = 'tile';
            if(isDora(tile.id)) d.classList.add('dora-tile');
            d.innerText = tile.char; div.appendChild(d);
        });
    }

    function showStatus(text) { document.getElementById('status-msg').innerText = text; }
    
    let onInfoClose = null;
    function showInfo(title, text, callback) {
        document.getElementById('info-title').innerText = title; document.getElementById('info-text').innerText = text;
        document.getElementById('info-panel').style.display = 'block'; onInfoClose = callback;
    }
    function closeInfo() {
        document.getElementById('info-panel').style.display = 'none';
        if(onInfoClose) { const cb = onInfoClose; onInfoClose = null; cb(); }
    }

    function openPicker(title, desc) {
        document.getElementById('picker-title').innerText = title; document.getElementById('picker-desc').innerText = desc;
        selectedTiles = []; renderPickerTiles(); updatePickedDisplay();
        
        const modalOverlay = document.getElementById('picker-modal');
        const modalContent = modalOverlay.querySelector('.modal-content');
        if (pickerMode === 'GUESS') {
            modalOverlay.classList.add('glass-mode');
            modalContent.classList.add('glass-mode');
        } else {
            modalOverlay.classList.remove('glass-mode');
            modalContent.classList.remove('glass-mode');
        }
        
        modalOverlay.style.display = 'flex';
    }
    function closePicker() { document.getElementById('picker-modal').style.display = 'none'; }
    function renderPickerTiles() {
        const area = document.getElementById('tile-picker-area'); area.innerHTML = '';
        const groups = [{start:0,end:8},{start:9,end:17},{start:18,end:26},{start:27,end:33}];
        groups.forEach(g => {
            let gd = document.createElement('div'); gd.className = 'tile-picker-group';
            for(let i=g.start; i<=g.end; i++) {
                let t = document.createElement('div'); t.className = 'tile'; t.innerText = TILES[i];
                t.onclick = () => togglePick(i, t); t.dataset.id = i; gd.appendChild(t);
            }
            area.appendChild(gd);
        });
    }
    function togglePick(id, el) {
        if(selectedTiles.includes(id)) { selectedTiles = selectedTiles.filter(x=>x!==id); el.classList.remove('selected'); }
        else {
            if(pickerMode === 'GUESS' && selectedTiles.length >= 2) {
                let f = selectedTiles.shift(); document.querySelector(`.tile-picker-group .tile[data-id="${f}"]`)?.classList.remove('selected');
            }
            selectedTiles.push(id); el.classList.add('selected');
        }
        updatePickedDisplay();
    }
    function submitPicker() {
        if(selectedTiles.length === 0) return;
        if(pickerMode === 'DECLARE') {
            players.user.waits = [...selectedTiles];
            closePicker(); 
            
            // [ä¿®æ­£ 1] é€²å…¥å®£å‘Šç‹€æ…‹ï¼Œè¦æ±‚æ‰“ç‰Œ
            isDeclaring = true;
            showStatus("è«‹æ‰“å‡ºå‰›æ‘¸åˆ°çš„ç‰Œï¼ˆæœ€å³é‚Šï¼‰ä»¥ç¢ºç«‹è½ç‰Œï¼");
            updateUI(); // åˆ·æ–°UIä»¥æ›´æ–°ç‹€æ…‹
            
        } else if (pickerMode === 'GUESS') {
            if(selectedTiles.length !== 2) { alert("è«‹é¸ 2 å¼µ"); return; }
            closePicker(); checkGuess(selectedTiles);
        }
    }

    startNewRound();
</script>
</body>
</html>
